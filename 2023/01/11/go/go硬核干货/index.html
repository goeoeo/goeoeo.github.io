<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="D033aiBRFi">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://phpdi.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="字符串字符串结构: 指向数据地址的指针(8字节)+字符串长度变量(8字节) 1.string 不可修改,因为在字符串会被分配到只读内存段。2.将字符串转换为slice([]byte) ,是重新分配了内存，不会修改原有字符串。3.使用unsafe包 将slice 指向原字符串的内存，也不能修改，强制修改会包 panic">
<meta property="og:type" content="article">
<meta property="og:title" content="go&#x2F;go硬核干货">
<meta property="og:url" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/index.html">
<meta property="og:site_name" content="goeoeo">
<meta property="og:description" content="字符串字符串结构: 指向数据地址的指针(8字节)+字符串长度变量(8字节) 1.string 不可修改,因为在字符串会被分配到只读内存段。2.将字符串转换为slice([]byte) ,是重新分配了内存，不会修改原有字符串。3.使用unsafe包 将slice 指向原字符串的内存，也不能修改，强制修改会包 panic">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/bmap.png">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img.png">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_1.png">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_2.png">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_3.png">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_4.png">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_5.png">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_6.png">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_7.png">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_8.png">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_9.png">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_10.png">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_11.png">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_12.png">
<meta property="og:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_13.png">
<meta property="article:published_time" content="2023-01-11T14:59:23.574Z">
<meta property="article:modified_time" content="2023-07-30T14:27:22.566Z">
<meta property="article:author" content="Chen Yu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/bmap.png">

<link rel="canonical" href="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>go/go硬核干货 | goeoeo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">goeoeo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">会吃鱼</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://phpdi.github.io/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpeg">
      <meta itemprop="name" content="Chen Yu">
      <meta itemprop="description" content="自律给我自由">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="goeoeo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          go/go硬核干货
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-11 22:59:23" itemprop="dateCreated datePublished" datetime="2023-01-11T22:59:23+08:00">2023-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 22:27:22" itemprop="dateModified" datetime="2023-07-30T22:27:22+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串结构: 指向数据地址的指针(8字节)+字符串长度变量(8字节)</p>
<p>1.string 不可修改,因为在字符串会被分配到只读内存段。<br>2.将字符串转换为slice([]byte) ,是重新分配了内存，不会修改原有字符串。<br>3.使用unsafe包 将slice 指向原字符串的内存，也不能修改，强制修改会包 panic</p>
<a id="more"></a>

<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><p>slice结构: 指向数据地址的指针(8字节)+len当前slice长度(8字节)+cap 底层数组的长度(8字节)</p>
<h2 id="slice-扩容规则"><a href="#slice-扩容规则" class="headerlink" title="slice 扩容规则"></a>slice 扩容规则</h2><p>step1: 预估扩容后的容量</p>
<ol>
<li>预估容量*2 &lt; cap -&gt;newCap=cap</li>
<li>如果oldLen &lt; 1024 -&gt; newCap=oldCap<em>2 ,否则 newCap=oldCap</em>1.25</li>
</ol>
<blockquote>
<p>golang1.16.5 后 是oldCap &lt; 1024 -&gt; newCap=oldCap<em>2 ,否则 newCap=oldCap*1.25 step2: newCap个元素需要多大的内存<br>内存= 预估容量</em> 元素类型大小</p>
</blockquote>
<p>step3: 匹配到合适的内存规格</p>
<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><h2 id="为什么要内存对齐？"><a href="#为什么要内存对齐？" class="headerlink" title="为什么要内存对齐？"></a>为什么要内存对齐？</h2><p>cpu为了快速读取内容，</p>
<h2 id="什么是内存对齐-？"><a href="#什么是内存对齐-？" class="headerlink" title="什么是内存对齐 ？"></a>什么是内存对齐 ？</h2><p>为保证程序顺利高效的运行，编译器会把各种类型的数据安排到合适的地址，并占用合适的长度，这就是内存对齐 。 每种类型的对齐值，就是他的对齐边界</p>
<p>内存对齐要求数据存储地址，以及占用的字节数都要是他对齐边界的倍数</p>
<h2 id="平台对应的最大对齐边界"><a href="#平台对应的最大对齐边界" class="headerlink" title="平台对应的最大对齐边界"></a>平台对应的最大对齐边界</h2><p>寄存器宽度、机器字长<br>数据类型的对齐边界为与平台最大对齐边界取较小的那个。</p>
<h2 id="结构体占用字节数"><a href="#结构体占用字节数" class="headerlink" title="结构体占用字节数?"></a>结构体占用字节数?</h2><p>结构体字节数需要是对齐边界的倍数，因为要考虑数组。只有每个结构体的大小是对齐值的整数倍，才能保证数组里面每个类型都是内存对齐的。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>键值对的存储一般都会使用hash表<br>哈希表通常会有一堆桶（buckets）来存储键值对，通过哈希函数将键值对的键处理成键hash值，利用hash值来选择桶</p>
<h2 id="选桶算法-m为桶的数量-："><a href="#选桶算法-m为桶的数量-：" class="headerlink" title="选桶算法(m为桶的数量)："></a>选桶算法(m为桶的数量)：</h2><ol>
<li>取模法 hash%m</li>
<li>与运算 hash&amp;(m-1)</li>
</ol>
<blockquote>
<p>golang 使用的与运算法。</p>
</blockquote>
<h2 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h2><p>两个key通过hash函数算出的hash值相同<br>解决hash冲突的办法</p>
<ol>
<li>开放地址法，将冲突的hash放到下一个的桶中寻找，当桶找不到则到下一个桶中寻找，直到遇到空桶</li>
<li>拉链法，编号为2的桶被占用了，在2后面链一个新桶，当前桶找不到，去链接的桶里面寻找。<br>hash的发送会影响哈希表的读写效率，选择散列均匀的hash函数可以减少hash冲突的发生，适时的对哈希表进行扩容也是保证读写效率的有效手段</li>
</ol>
<h2 id="hash扩容"><a href="#hash扩容" class="headerlink" title="hash扩容"></a>hash扩容</h2><p>通常会吧存储键值对的数据与桶数目的比值作为是否需要扩容的判断依据，这个比值叫<strong>负载因子(LoadFactor)</strong><br>数据迁移，把旧桶里存储的键值对都迁移到新桶里。如果哈希表存储的键值对较多，一次性迁移所有桶花费的时间比较显著，所以通常会在哈希表扩容时，先分配足够多的新桶 然后用一个字段记录旧桶的位置，再增加一个字段记录旧桶迁移的进度(<br>如记录下一个需要迁移的旧桶编号)，如果hash表每次在进行读写操作时，如果检测到当前处于扩容阶段<br>就完成一部分键值对迁移任务，直到所有的旧桶迁移完成，旧桶不在使用，才算真正完成一次哈希表的扩容，像这样把键值对迁移的时间分摊到多次哈希表操作的方式，叫做渐进式扩容。<br>渐进式扩容，可以避免一次性扩容的瞬时抖动。</p>
<h2 id="go语言中Map类型的底层实现就是哈希表"><a href="#go语言中Map类型的底层实现就是哈希表" class="headerlink" title="go语言中Map类型的底层实现就是哈希表"></a>go语言中Map类型的底层实现就是哈希表</h2><p>Map 类型的变量本质上是一个指针, 指向hmap<br>一个桶里可以放8个键值对，但是为了让内存更加紧凑，8个key放一起，8个value放一起，在8个key前面是8个tophash<br>每个tophash都是对应hash值的高8位 ,overflow 存的是溢出桶<br>实际上如果哈希表要分配桶的数据大于2^4次方，就会认为使用溢出桶的几率比较大，就会预分配2^(B-4)个溢出桶备用<br><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/bmap.png" alt></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Map</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"unsafe"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Map 底层结构体</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count      <span class="keyword">int</span> <span class="comment">//键值对数目</span></span><br><span class="line">	flags      <span class="keyword">uint8</span></span><br><span class="line">	B          <span class="keyword">uint8</span>  <span class="comment">//B 记录桶的数目的幂，桶数=2^B，因为选择桶用的是与运算的方法</span></span><br><span class="line">	noverflow  <span class="keyword">uint16</span> <span class="comment">//使用溢出桶的数量</span></span><br><span class="line">	hash0      <span class="keyword">uint32</span></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">//当前桶</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">//旧桶</span></span><br><span class="line">	nevacuate  <span class="keyword">uintptr</span>        <span class="comment">//渐进式扩容阶段，即将迁移的旧桶编号</span></span><br><span class="line">	extra      *mapextra</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录溢出桶的相关信息</span></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">	overflow     unsafe.Pointer <span class="comment">//已经使用的溢出桶</span></span><br><span class="line">	oldoverflow  unsafe.Pointer <span class="comment">//用于在扩容阶段存储旧通用到的那些溢出桶的地址</span></span><br><span class="line">	nextoverflow unsafe.Pointer <span class="comment">//下一个空闲溢出桶</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桶</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="go-Map的扩容规则"><a href="#go-Map的扩容规则" class="headerlink" title="go Map的扩容规则"></a>go Map的扩容规则</h2><ul>
<li>count/(2^5) &gt; 6.5 =&gt; 翻倍扩容</li>
<li>LoadFactor没有超标并且noverflow 较多 =&gt; 等量扩容</li>
</ul>
<blockquote>
<p>noverflow较多的情况:<br>1.B&lt;=15,noverflow&gt;2^B<br>2.B&gt;15,noverflow&gt;2^15</p>
</blockquote>
<h3 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h3><p>创建与原来相同数量的桶<br>为什么要进行等量扩容？<br>在溢出桶使用较多，负载因子较低的时候，说明删除了大量的键。通过等量扩容，减少溢出桶的使用。</p>
<h1 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h1><p>我们按照编程语言的语法定义的函数，会被编译器编译成一堆堆的机器指令，写入可执行文件。<br>执行时，可以执行文件被加载到内存中，这些机器指令，对应虚拟地址空间中位于代码段。如果在一个函数中调用另外一个函数，编译器就会生成一条call指令。<br>程序执行到这条指令时，就会跳转到被调用函数入口处开始执行，而每个函数的最后都有一条ret指令，负责在函数结束后，调回到调用处，继续执行。<br>函数执行时，需要有足够的内存空间，供它存放局部变量、参数等数据，这段空间对应到虚拟地址空间的栈，栈只有一个口可以出，先入后出规则<br>运行时，栈上面是高地址，向下增长，分配给函数的栈空间称为函数栈帧（stack frame），函数栈帧由栈底（bp 栈基）到栈顶（sp 栈指针）</p>
<p><strong>go 语言中函数栈帧布局</strong><br>调用者栈基地址<br>局部变量<br>调用函数的返回值<br>参数</p>
<p>call 指令 只做两件事，第一将下一条指令的地址入栈，这就是返回地址，被调用函数执行结束后会跳回到这里，继续执行。第二跳转到被调用函数的入口<br>处执行，所有的函数栈帧布局都遵循统一的约定，所以被调用者是通过栈指针加上偏移来定位到每一个参数好返回值的<br>程序执行时cpu 用特定的寄存器，来存储运行时 栈基和栈指针，用指令指针寄存器用于存储下一条要执行的指令地址<br>go语言中函数栈帧不是逐步扩张的，而是在分配栈帧时，直接将栈指针移动到所需最大栈空间的位置，然后通过栈指针加偏移值，这种相对寻址方式使用函数 栈帧。之所以一次行分配，主要是为了避免发送栈访问越界。</p>
<p>ret 指令 1.弹出返回地址，2.跳转到返回地址。<br>每个函数开始时会分配栈帧，结束前又会释放自己的栈帧</p>
<h2 id="go语言中返回值赋值早于defer函数"><a href="#go语言中返回值赋值早于defer函数" class="headerlink" title="go语言中返回值赋值早于defer函数"></a>go语言中返回值赋值早于defer函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      a++</span><br><span class="line">      b++</span><br><span class="line">   &#125;()</span><br><span class="line">   a++</span><br><span class="line">   b = a</span><br><span class="line">   <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line">   b = incr(a)</span><br><span class="line">   fmt.Println(a,b)<span class="comment">//0,1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="params">(b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      a++</span><br><span class="line">      b++</span><br><span class="line">   &#125;()</span><br><span class="line">   a++</span><br><span class="line">   <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line">   b = incr(a)</span><br><span class="line">   fmt.Println(a,b)<span class="comment">//0,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一个函数中调用了多个函数，且参数和返回值各不相同"><a href="#一个函数中调用了多个函数，且参数和返回值各不相同" class="headerlink" title="一个函数中调用了多个函数，且参数和返回值各不相同"></a>一个函数中调用了多个函数，且参数和返回值各不相同</h2><p>如果一个函数A调用了两个函数B、C ,但是这两个函数的参数和返回值占用的空间并不相同，go语言的函数栈帧是一次性分配的，要<br>以最大的参数加返回值空间为标准来分配，才能满足所有被调用函数的需求。被调用者通过栈指针相对寻址来定位自己的参数和返回值</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>go 语言中函数是头等对象，可以作为参数传递，可以作为函数返回值，也可以绑定到变量，Go语言称这样的参数、返回值、或变量为function value，<br>函数指令在编译起见生成，而function value 本质上是一个指针，但是并不直接指向函数指令入口，而是指向一个runtime.funcval的结构体,这个结<br>构体里只有一个地址fn，这个地址就是函数指令的入口地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> runtime</span><br><span class="line"><span class="keyword">type</span> funcval <span class="keyword">struct</span> &#123;</span><br><span class="line">	fn <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为什么需要通过funcval结构体来包装执行函数的地址-然后使用一个二级指针来调用呢？"><a href="#为什么需要通过funcval结构体来包装执行函数的地址-然后使用一个二级指针来调用呢？" class="headerlink" title="为什么需要通过funcval结构体来包装执行函数的地址,然后使用一个二级指针来调用呢？"></a>为什么需要通过funcval结构体来包装执行函数的地址,然后使用一个二级指针来调用呢？</h2><p>这里主要是为了处理闭包的情况。  </p>
<blockquote>
<p>闭包：要包括自由变量（在函数外部定义但在函数内部引用）；脱离了形成闭包的上下文，闭包也能正常使用这些自由变量</p>
</blockquote>
<p><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img.png" alt><br>函数create 的返回值是一个函数，但这个函数内部使用了外部定义的变量c，即使create执行结束，通过f1，f2也能正常执行这个闭包函数，并使用定义<br>在create函数内部的局部变量c，所以这里符合闭包的定义，通常称这个变量c为捕获变量。<br>闭包函数的指令自然也在编译阶段生成，但因为每个闭包对象都要保存自己的捕获变量，所以要到执行阶段才创建对应的闭包对象。<br>到执行阶段，main函数栈帧有两个局部变量，然后是返回值空间，到create函数栈帧这里，有一个局部变量c等于2，create函数会在堆上分配一个fucval<br>结构体，fn指向闭包函数入口，除此之外还有一个捕获列表，这里只捕获了一个变量c，然后这个结构体的起始地址就作为返回值，写入返回值空间。<br>通过f1、f2，对应的闭包函数就会找到各自对应的funcval结构体，拿到同一个函数入口，但是会使用不同的捕获列表，这就是称闭包为有状态函数的原因</p>
<h2 id="闭包函数是如何找到对应的捕获列表呢？"><a href="#闭包函数是如何找到对应的捕获列表呢？" class="headerlink" title="闭包函数是如何找到对应的捕获列表呢？"></a>闭包函数是如何找到对应的捕获列表呢？</h2><p>go语言中通过一个funcval 调用函数时，会把对应的funcval结构体地址存入特定寄存器，例如amd64平台使用的是dx寄存器，这样在闭包函数中就可以通<br>过寄存器取出funcval结构体的地址，然后加上响应的偏移来找到每一个被捕获的变量。<br>所以go语言中，闭包就是有捕获列表的funcval，而没有捕获列表的funcval，直接忽略这个寄存器的值就好了。  </p>
<h2 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h2><p>捕获列表 不单单只是拷贝变量值。需要分情况。被闭包捕获的变量，在外层函数与闭包函数中表现一致，好像他们在使用同一个变量，为此go语言的编译器<br>针对不同情况做了不同的处理</p>
<h3 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h3><p>被捕获的变量除了初始化复制外，在其它任何地方都没有修改过<br>直接拷贝值到捕获列表中</p>
<h3 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h3><p>局部变量除了初始化赋值外还被修改过。<br>变量会改为堆分配，捕获列表中存的是变量的地址</p>
<blockquote>
<p>局部变量堆分配，是变量逃逸的一种场景。</p>
</blockquote>
<h3 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h3><p>如果修改并被捕获的是参数，涉及到函数原型，就不能像局部变量那样处理了<br>参数依然通过调用者栈帧传入，但是编译器会把栈上这个参数拷贝到堆上一份，然后外层函数和闭包函数都使用堆上分配的这一个，</p>
<h3 id="情况4"><a href="#情况4" class="headerlink" title="情况4"></a>情况4</h3><p>如果被捕获的是返回值<br>调用者栈帧上依然会分配返回值空间，不过闭包的外层函数会在堆上也分配一个，外层函数和闭包函数都使用堆上分配的这一个，在外层函数返回前，需要<br>把堆上的返回值拷贝到栈上的返回值空间</p>
<p>处理方式虽然多样，但目的只有一个，就是保持捕获变量在外层函数与闭包函数的一致性。  </p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>如果我们定义一个类型A,并给它定义一个方法Name,然后就可以使用 a.Name 或者 A.Name(a) 来调用Name方法，实际上a.Name是调用语法糖<br><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_1.png" alt><br>go语言中 函数只和参数类型与返回值相关，方法就是普通的函数，方法的接受者是隐含的第一个参数</p>
<h2 id="方法表达式与方法变量"><a href="#方法表达式与方法变量" class="headerlink" title="方法表达式与方法变量"></a>方法表达式与方法变量</h2><p><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_2.png" alt><br>方法表达和方法变量 本质上都是一个funcval，方法变量会捕获方法接受者a形成闭包,但这里的f2仅作为局部变量，它与a的生命周期是一致的，所以编译器<br>会做出优化，把它转换为类型A的方法调用并传入a作为参数 A.Name(a),</p>
<h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><p>关于defer 我们知道它会在函数返回之前倒叙执行。<br>先通过deferproc函数注册defer函数，然后在return之前调用。<br>defer信息会注册到一个链表，而当前执行的goroutine持有这个链表的头指针，每个goroutine在执行时都有一个对应的结构体g，其中有一个字段_defer指向<br>defer链表的头，_defer 链表链起来的是一个一个defer结构体，新注册的defer会添加到链表的头部。执行时也是从头开始，所以defer才会表现为倒叙执行。  </p>
<p>defer 结构体<br><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_3.png" alt></p>
<h2 id="go1-12defer-的问题"><a href="#go1-12defer-的问题" class="headerlink" title="go1.12defer 的问题"></a>go1.12defer 的问题</h2><ol>
<li>_defer在堆上分配 ，即使有预分配的deferpool,也需要去堆上获取与释放，而且参数还要在堆栈间来回拷贝  </li>
<li>使用链表注册defer信息，而链表本身操作比较慢</li>
</ol>
<h2 id="go1-13和go1-14对defer的改进"><a href="#go1-13和go1-14对defer的改进" class="headerlink" title="go1.13和go1.14对defer的改进"></a>go1.13和go1.14对defer的改进</h2><p>go1.14的defer，通过在编译阶段插入代码, 把defer函数的执行逻辑展开在所属函数内，open code defer，和1.13一样不适用于循环中的defer，循环中<br>defer，由于在编译阶段无法确定数量，所以只能在堆分配。<br>go1.14defer 性能提升了一个数量级，open codeed defer 未注册到defer连表中，所以在发生panic和runtime.Goexit的时候，需要额外进行栈扫描来<br>执行未注册到链表中的defer。所以panic变慢了。  </p>
<h1 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h1><p>当前执行的goroutine 中有一个defer链表的头指针，同时也有个以panic链表的头指针，panic连起来的是一个个panic结构体，当发生新的panic的时候，<br>也是在链表的头上插入新的panic结构体。<br>panic 结构体<br><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_4.png" alt="go硬核干货"><br>panic触发defer执行，最后从连表尾部打印异常信息。  </p>
<h2 id="panic-两点重要信息"><a href="#panic-两点重要信息" class="headerlink" title="panic 两点重要信息"></a>panic 两点重要信息</h2><ul>
<li>panic执行defer函数的方式为先标记后释放，目的是为了终止之前发生的panic  </li>
<li>所有还在panic链表上的项都会被输出，顺序与panic发生的顺序一致</li>
</ul>
<h1 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h1><p>方法本质上就是函数，只不过在调用时，接受者会作为第一个参数传入<br>在定义方法的时候不能为内置类型和接口定义方法。<br>内置类型和自定义类型，都有其对应的描述信息，称为他的“类型元数据”，每种类型元数据都是全局唯一的,这些类型元数据共同构成了go语言的“类型系统”</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="空接口-interface"><a href="#空接口-interface" class="headerlink" title="空接口 interface{}"></a>空接口 interface{}</h2><p><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_5.png" alt="img.png">  </p>
<p>未被赋值前，_type=nil,data=nil 赋值后，_type指向类型元数据 ，data指向数据</p>
<h2 id="非空接口"><a href="#非空接口" class="headerlink" title="非空接口"></a>非空接口</h2><p>一个变量想要赋值给一个非空接口类型，必须要实现这个非空接口类型的所有方法。<br><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_6.png" alt="img.png">    </p>
<p><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_7.png" alt="img.png"><br>如果我们声明一个io.ReadWriter类型的变量rw,它被赋值以前data=nil,tab=nil,吧一个<em>os.File的类型变量f 赋值给rw,此时rw的动态值就是f,而tab<br>会指向一个itab结构体，他的接口类型为io.ReadWriter,动态类型为</em>os.File ,同时注意itab这里的fun，它会从动态类型元数据中拷贝接口要求的那些<br>方法的地址，以便通过rw快速定位到方法而无需再去类型元数据那里查找。  </p>
<p>关于itab 还要额外关注一点，一旦接口类型确定了，动态类型确定了，那么itab的内容就不会改变了。那这个itab结构体也就确定了。所以这个itab结构体是可以复用的<br>实际上go语言会吧itab结构体缓存起来，并且以接口类型和动态类型的组合为key，以itab结构体指针为value,构造一个hash表，用于存储和查询itab缓存信息，<br>这里的hash表和map底层的hash表不同，是一种更为简便的设计，需要一个itab结构体是，会首先去这里查找，用接口类型的hash值和动态类型的hash值，进行异或运算得到<br>key的hash值，如果已经有对应的itab指针就直接拿来使用，如果没有就创建一个itab结构体，然后添加到这个hash表中。</p>
<h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>抽象类型： 空接口、非空接口<br>具体类型：int、string、slice、map、struct。。。<br>类型断言作用在接口值之上，可以是空接口，也可以是非空接口，断言的目标类型可以是非空接口类型、也可以是具体类型。</p>
<ul>
<li>空接口.(具体类型)</li>
<li>非空接口.(具体类型)</li>
<li>空接口.(非空接口)</li>
<li>非空接口.(非空接口)</li>
</ul>
<h1 id="反射-reflect"><a href="#反射-reflect" class="headerlink" title="反射 reflect"></a>反射 reflect</h1><p>runtime包中的空接口和非空接口的类型元数据都是未导出的，所以reflect包中又定义了一套和runtime包中保持一致。<br>reflect包提供TypeOf 函数，用于获取变量的类型信息，接受一个空接口类型的参数，并返回一个reflect.Type类型的返回值。<br>所有参数为空接口类型的情况，通过传递拷贝后的变量的地址，来实现传值的语义   </p>
<p>通过reflect.ValueOf 来获取值，如果需要修改原变量的值，需要传指针。</p>
<h1 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h1><h2 id="golang调度器的由来"><a href="#golang调度器的由来" class="headerlink" title="golang调度器的由来"></a>golang调度器的由来</h2><h3 id="单进程时代的两个问题"><a href="#单进程时代的两个问题" class="headerlink" title="单进程时代的两个问题"></a>单进程时代的两个问题</h3><ol>
<li>单一执行流程，计算机一个任务一个任务处理</li>
<li>进程阻塞锁带来的CPU浪费时间  </li>
</ol>
<h3 id="多进程、多线程的问题"><a href="#多进程、多线程的问题" class="headerlink" title="多进程、多线程的问题"></a>多进程、多线程的问题</h3><ol>
<li>设计变得复杂</li>
</ol>
<ul>
<li>进程、线程数量越多，切换成本就越大，也就越浪费</li>
<li>多线程 随着同步竞争（如锁、竞争资源冲突等）</li>
</ul>
<ol start="2">
<li>多进程、多线程的壁垒</li>
</ol>
<ul>
<li>进程占用内存 虚拟内存4GB(32bit OS),线程占用内存 4MB</li>
<li>高CPU调度消耗</li>
</ul>
<h3 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h3><ol>
<li>N:1 无法利用多个CPU,出现阻塞的瓶颈</li>
<li>1:1 跟多线程、多进程模型无异 ；切换携程成本代价昂贵</li>
<li>M:N 能够利用多核，过于依赖协程调度器的优化和算法  </li>
</ol>
<h3 id="golang-调度器的优化"><a href="#golang-调度器的优化" class="headerlink" title="golang 调度器的优化"></a>golang 调度器的优化</h3><ul>
<li>占用空间小，4kb,可大量开辟</li>
<li>灵活调度 切换成本底</li>
</ul>
<h2 id="GMP模型设计思想"><a href="#GMP模型设计思想" class="headerlink" title="GMP模型设计思想"></a>GMP模型设计思想</h2><p><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_8.png" alt="img.png"></p>
<h3 id="GMP模型简介"><a href="#GMP模型简介" class="headerlink" title="GMP模型简介"></a>GMP模型简介</h3><h4 id="GMP含义"><a href="#GMP含义" class="headerlink" title="GMP含义"></a>GMP含义</h4><ul>
<li>G 携程</li>
<li>P 处理器 通过GOMAXPROCS 设置<blockquote>
<p>为什么p的个数要和cpu个数一致，因为并行执行的最大数量为cpu核数</p>
</blockquote>
</li>
<li>M 内核线程<h4 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h4>存放等待运行的G<br>包含全局队列锁<h4 id="P的本地队列"><a href="#P的本地队列" class="headerlink" title="P的本地队列"></a>P的本地队列</h4></li>
<li>存放等待运行的G</li>
<li>数量限制，不超过256G</li>
<li>优先将新创建的G放在P的本地队列中，如果满了会放在全局队列中<h4 id="P列表"><a href="#P列表" class="headerlink" title="P列表"></a>P列表</h4></li>
<li>程序启动时候创建</li>
<li>最多有GOMAXPROCS个</li>
</ul>
<h4 id="M列表"><a href="#M列表" class="headerlink" title="M列表"></a>M列表</h4><p>当前操作系统分配到当前Go程序的内核线程数</p>
<h4 id="P和M的数量"><a href="#P和M的数量" class="headerlink" title="P和M的数量"></a>P和M的数量</h4><p>P的数量问题   </p>
<ol>
<li>环境变量$GOMAXPROCS  </li>
<li>在程序中使用runtime.GOMAXPROCS()方法来设置</li>
</ol>
<p>M的数量问题</p>
<ol>
<li>GO语言本身限定的M最大量是10000 </li>
<li>runtime/debug 包中的SetMaxThreads函数来设置</li>
<li>如果有一个M阻塞，会创建新的M,如果M空闲，那么会回收或者随眠，M的数量是一个动态的值</li>
</ol>
<h3 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h3><h4 id="复用线程"><a href="#复用线程" class="headerlink" title="复用线程"></a>复用线程</h4><p>避免频繁的创建、销毁线程、而是对线程的复用  </p>
<ul>
<li>work stealing机制<blockquote>
<p>当本线程无可运行的G时，尝试从其它线程绑定的P偷取G,而不是销毁线程 </p>
</blockquote>
</li>
<li>handle off 机制  <blockquote>
<p>当本线程因为G进行系统调用阻塞时，线程释放绑定的P,把P转移给其它空闲的线程执行</p>
</blockquote>
<h4 id="利用并行"><a href="#利用并行" class="headerlink" title="利用并行"></a>利用并行</h4>GOMAXPROCS 设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行  </li>
</ul>
<h4 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h4><p>在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在GO中，一个goroutine最多占用CPU 10 ms,防止其他goroutine被饿死<br><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_9.png" alt="img.png"></p>
<h4 id="全局G队列"><a href="#全局G队列" class="headerlink" title="全局G队列"></a>全局G队列</h4><p>当M执行work stealing从其它P偷不到G时，它可以从全局队列获取G</p>
<h3 id="go-fun-经历了什么过程"><a href="#go-fun-经历了什么过程" class="headerlink" title="go fun() 经历了什么过程"></a>go fun() 经历了什么过程</h3><p>我们通过go func 来创建一个goroutine;  </p>
<p>有多个存储G的队列，一个是局部调度器P的本地队列，一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了<br>就会保存在全局的队列中  </p>
<p>G只能运行在M中，一个M必须持有一个P,M与P是1:1的关系，M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会<br>想其它的MP组合偷取一个可执行的G来执行  </p>
<p>一个M调度G执行的过程是一个循环机制</p>
<p>当M执行某一个G时候如果发生了syscall或则其余的阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除（detach），<br>然后再创建一个新的操作系统的线程（如果有空闲的线程可用就复用空闲线程）来服务于这个P</p>
<p><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_10.png" alt="img.png"></p>
<h3 id="调度器的生命周期"><a href="#调度器的生命周期" class="headerlink" title="调度器的生命周期"></a>调度器的生命周期</h3><h4 id="M0"><a href="#M0" class="headerlink" title="M0"></a>M0</h4><p>M0 是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动<br>第一个G，在之后M0就和其他的M一样了。  </p>
<h4 id="G0"><a href="#G0" class="headerlink" title="G0"></a>G0</h4><p>G0是每次启动一个M都会第一个创建的goroutine,GO仅用于负责调度G,G0不指向任何可执行的函数，每个M都会有一个自己的G0。在调度或者系统<br>调用时会使用G0的栈空间，全局变量的G0是M0的G0</p>
<h3 id="可视化的GMP编程"><a href="#可视化的GMP编程" class="headerlink" title="可视化的GMP编程"></a>可视化的GMP编程</h3><h4 id="trance编程"><a href="#trance编程" class="headerlink" title="trance编程"></a>trance编程</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"os"</span></span><br><span class="line">   <span class="string">"runtime/trace"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   f, err := os.Create(<span class="string">"trace.out"</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> f.Close()</span><br><span class="line">   trace.Start(f)</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">   </span><br><span class="line">   trace.Stop()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>go tool trace trace.out  浏览器访问</p>
</blockquote>
<h4 id="通过Debug-trance查看GMP信息"><a href="#通过Debug-trance查看GMP信息" class="headerlink" title="通过Debug trance查看GMP信息"></a>通过Debug trance查看GMP信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GODEBUG=schedtrace=1000 程序</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1000指的是1000ms时间间隔</span></span><br><span class="line"></span><br><span class="line">SCHED 3014ms: gomaxprocs=8 idleprocs=8 threads=19 spinningthreads=0 idlethreads=14 runqueue=0 [0 0 0 0 0 0 0 0]</span><br></pre></td></tr></table></figure>

<ul>
<li>SCHED 调试信息</li>
<li>3014ms 从程序启动到输出经历的时间</li>
<li>gomaxprocs P的数量 默认是和CPU核心数是一致的</li>
<li>idleprocs 处理idel状态的p的数量，gomaxprocs-idleprocs=目前正在执行的P的数量</li>
<li>threads 线程数量(包括M0,包括GODEBUG调试的信息)</li>
<li>spinningthreads 处于自旋状态的线程数量</li>
<li>idlethreads idle状态的tread</li>
<li>runqueue 全局队列中G的数量</li>
<li>[0 0 0 0 0 0 0 0] 每个P的local queue本地队列中，目前存在G的数量</li>
</ul>
<h2 id="GO调度器GMP场景过程全分析"><a href="#GO调度器GMP场景过程全分析" class="headerlink" title="GO调度器GMP场景过程全分析"></a>GO调度器GMP场景过程全分析</h2><h3 id="G1创建G3"><a href="#G1创建G3" class="headerlink" title="G1创建G3"></a>G1创建G3</h3><p>局部性: G3优先加入G1所在的本地队列  </p>
<p>P拥有G1,M1获取P后开始运行G1,G1使用go func() 创建G2,为了局部性G2优先加入到P1的本地队列</p>
<h3 id="G1执行完毕"><a href="#G1执行完毕" class="headerlink" title="G1执行完毕"></a>G1执行完毕</h3><p>G1运行完成后（函数：goexit）,M上运行的goroutine切换为G0,G0负责调度时协程的切换（函数:schedule）。<br>从P的本地队列获取G2,从G0切换到G2,并开始执行G2(函数:execute)。实现了线程M1的复用</p>
<h3 id="更多场景见"><a href="#更多场景见" class="headerlink" title="更多场景见"></a>更多场景见</h3><p><a href="https://www.yuque.com/aceld/golang/srxd6d#5c3da99e" target="_blank" rel="noopener">https://www.yuque.com/aceld/golang/srxd6d#5c3da99e</a></p>
<blockquote>
<p>Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发</p>
</blockquote>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>垃圾回收指的是回收在堆上，不再使用的数据。栈上的内存会随着栈的释放而被销毁<br>有效数据指的是从栈（stack 正在执行的函数）能追踪到，数据段（全局变量，静态数据），从这些根节点追踪不到的数据则认为是垃圾可以清除<br>主流的垃圾算法都是使用可达性，近似等价于存活性的算法  </p>
<h2 id="标记清扫算法"><a href="#标记清扫算法" class="headerlink" title="标记清扫算法"></a>标记清扫算法</h2><p>追踪式垃圾回收<br>从 栈，数据段 上的对象作为root对象，基于它们进一步追踪，把能追踪到的数据进行标记，追踪不到的数据，则视为垃圾，进行清理  </p>
<h3 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h3><p>三色追踪可以清晰的展现追踪式回收过程中对象状态的变化过程<br>标记过程：  </p>
<ol>
<li>垃圾回收开始时所有对象均为白色  </li>
<li>把直接追踪到的root节点标记为灰色，灰色代表基于当前节点展开的追踪尚未完成  </li>
<li>当基于某个节点的追踪任务完成后，便会把改节点标记为黑色，表示它是存活数据，无需基于它再次进行追踪，基于黑色节点找到的所有节点，都为标记为灰色，表示还要基于它们进步展开追踪</li>
<li>当没有灰色节点时意味着标记工作结束了，剩下的白色对象视为垃圾，执行清除</li>
</ol>
<h3 id="标记清扫算法带来的问题和解决方案"><a href="#标记清扫算法带来的问题和解决方案" class="headerlink" title="标记清扫算法带来的问题和解决方案"></a>标记清扫算法带来的问题和解决方案</h3><p>标记清扫算法实现起来相对简单，但是容易造成内存碎片化，回收完的内存要找到合适的内存分块的代价更高，也会造成很多小块内存无法使用的情况   </p>
<p>如何解决这个问题？  </p>
<ol>
<li>可以基于BiBop(Big Bag Of Pages)的思想 把内存块划分为多种不同大小的规格，对相同规格的内存块进行统一管理，这样可以更快的匹配到大小合适<br>的空闲内存，规格类型划分的合理也有助于提高内存的使用率</li>
<li>可以通过移动数据来减少碎片化的方法，例如在标记整理（mark-compact）算法中，标记阶段与标记清扫算法相同，但是就在标记清扫工作完成后，移动数据，使它们能够紧凑的放在内存中<br>虽然标记整理算法有效解决了内存碎片化的问题，但多次扫描与移动开销也不容小觑</li>
<li>复制式回收，会把堆内存划分为两个相等from和to空间，垃圾回收时，将from能追踪到的数据复制到to空间，所有数据复制完成后把from和to交换一下，这种<br>复制式回收也不会带来碎片化问题，但是只有一半的空间能被使用。为了提高堆内存的使用率，通常会和其它垃圾回收算法结合使用，只在一部分堆内存中使用复制式回收</li>
<li>分代回收 （弱分代假说，大部分对象都在年轻时死亡，如果把新创建的对象称为新生代对象，把经受住特定gc次数的对象称为老年代对象。基于弱分代假说，大部分对象会在<br>最初经历的垃圾回收中死亡，也就是新生代对象成为垃圾的概率高于老年代对象，所以可以把数据划分为新生代和老年代，降低老年代执行垃圾回收的频率），新生代<br>和老年代可以采用不同的垃圾回收策略，进一步提升效益减少开销</li>
</ol>
<h2 id="引用计数垃圾回收"><a href="#引用计数垃圾回收" class="headerlink" title="引用计数垃圾回收"></a>引用计数垃圾回收</h2><p>引用计数指的是一个对象被引用的次数，程序执行过程中会更新对象的引用计数，当引用计数更新为0时，就表示这个对象不再有用，就可以对他进行垃圾回收了，<br>引用计数法中垃圾识别的任务已经分摊到每一次数据对象的操作中了，虽然引用计数法可以及时回收无用内存，但高频率的更新引用计数，也是一笔不小的开销   </p>
<p>而且循环引用的情况下，永远无法回收</p>
<h2 id="STW（stop-the-word）"><a href="#STW（stop-the-word）" class="headerlink" title="STW（stop the word）"></a>STW（stop the word）</h2><p>垃圾回收执行时，用户程序长时间暂停<br>实际上我们总是希望尽量缩短STW的时间，可以将垃圾回收工作分多次完成。  </p>
<h2 id="垃圾回收的方式"><a href="#垃圾回收的方式" class="headerlink" title="垃圾回收的方式"></a>垃圾回收的方式</h2><h3 id="增量式垃圾回收"><a href="#增量式垃圾回收" class="headerlink" title="增量式垃圾回收"></a>增量式垃圾回收</h3><p>用户程序与垃圾回收程序交替执行，可以缩短每次垃圾回收的时间，但是交替执行的过程中，保不齐垃圾回收程序前脚标记了一个黑色对象，用户程序后脚又修改了它，<br>要是放任不管，垃圾回收程序就会误把存活数据当作垃圾回收 例如：黑色-&gt;白色</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>非移动式垃圾回收，需要建立写屏障<br>强三色不变式： 禁止黑色对象到白色对象的引用。<br>弱三色不变式： 允许黑色对象到白色对象的引用，但可以保证通过灰色对象可以抵达该白色对象。    </p>
<p>实现强弱三色不变式的方法，是建立读写屏障<br>写屏障是在写操作中插入指令，目的是吧数据对象的修改通知到垃圾回收器，写屏障通常会有一个记录集，而记录集是采用顺序存储还是使用哈希表，记录精确到被修改的<br>对象还是只记录其所在的页，是写屏障具体实现需要考虑的</p>
<ul>
<li>插入写屏障  针对于强三色不变式（黑色对象到白色对象的引用），需要吧黑色对象变为灰色，或者吧白色对象变为灰色</li>
<li>删除写屏障 关注哪些对象引用的破坏行为，要删除灰色对象对白色对象的引用时，可以把白色对象变为灰色</li>
</ul>
<h3 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h3><p>如果时复制式垃圾回收这样通过移动数据来避免碎片化，那GC和用户程序交替执行时，那么读数据也不那么安全了。<br>读屏障确保用户程序不会访问到已经存在副本的陈旧对象</p>
<h2 id="多核"><a href="#多核" class="headerlink" title="多核"></a>多核</h2><p>并行和并发回收的区别在于，同一时刻是否有多个线程在执行垃圾回收<br>go 语言的垃圾回收采用标记清扫算法，支持主体并发式增量垃圾回收，使用混合写屏障（插入写屏障，删除写屏障）</p>
<h3 id="并行垃圾回收"><a href="#并行垃圾回收" class="headerlink" title="并行垃圾回收"></a>并行垃圾回收</h3><p>暂停用户程序的前提下，多线程并行执行垃圾回收程序，这被称为并行垃圾回收</p>
<h3 id="并发垃圾回收"><a href="#并发垃圾回收" class="headerlink" title="并发垃圾回收"></a>并发垃圾回收</h3><p>指的时用户程序和垃圾回收程序并发执行，并发场景下，会存在用户程序和垃圾回收程序并行执行。这和并行垃圾回收中只考虑垃圾回收程序的执行时不同的<br>拿写屏障来说，用户程序和垃圾回收器可能会同时使用写屏障，那就需要考虑用户程序之间以及用户程序和垃圾回收器之间的竞争问题，如果没有任何stw的时间<br>那么垃圾回收开始的消息便很难准时准确的通知到所有线程，可能导致某些线程开启写屏障的动作有所延迟而发生错误，</p>
<h3 id="主体并发式垃圾回收"><a href="#主体并发式垃圾回收" class="headerlink" title="主体并发式垃圾回收"></a>主体并发式垃圾回收</h3><p>在实际应用中在某些开启stw，在其它阶段支持并发的 “主体并发式垃圾回收” 更容易实现，</p>
<h3 id="主体并发增量式回收"><a href="#主体并发增量式回收" class="headerlink" title="主体并发增量式回收"></a>主体并发增量式回收</h3><p>在主体并发回收的基础上，实现增量式回收</p>
<p><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_11.png" alt="img.png"></p>
<h2 id="GC-触发方式"><a href="#GC-触发方式" class="headerlink" title="GC 触发方式"></a>GC 触发方式</h2><ul>
<li>手动触发 runtime.GC</li>
<li>分配内存，每次GC都会在标记结束后设置下一次触发gc的内存分配量，分配大对象或者从mcentral获取空闲内存时，会判断是否达到了这个值</li>
<li>sysmon 系统监控，达到一定的时间间隔，强制执行gc</li>
<li>分配对象大小超过默认大小：Golang 的垃圾回收器将小对象与大对象分开处理。如果程序分配的对象大小超过了垃圾回收器的默认大小，就会触发垃圾回收</li>
</ul>
<h1 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="keyword">int32</span> <span class="comment">//存储互斥锁的状态 ，加锁和解锁通过 atomic包提供的函数原子性操作该字段</span></span><br><span class="line">	sema <span class="keyword">uint32</span> <span class="comment">//信号量，用于等待队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>互斥锁，结构简单，此结构体的零值为一个有效的互斥锁<br>互斥锁有两种模式，正常模式和饥饿模式</p>
<h2 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h2><p>一个尝试加锁的goroutine 会先自选几次，尝试通过原子操作获得锁，若几次操作后仍不能获得锁，则通过信号量排队，所有等待者会先按照先入先出（FIFO）的顺序排队。  </p>
<p>当锁被释放，第一个排队等待的goroutine需要和那些后来的处于自旋状态的goroutine竞争 ，这种情况下后来者更有优势，原因有两个：1.自旋状态的goroutine<br>正在cpu上运行，2.自旋状态的goroutine 有可能有多个，而被唤醒的goroutine只有一个。  </p>
<p>如果被唤醒的goroutine没有获得锁，将会重新插入导队列的头部</p>
<blockquote>
<p>正常模式下自旋和排队是同时存在的，这种排队之前先让大家来抢的模式可以提高吞吐量，因为频繁的挂起和唤醒goroutine会带来较多的开销</p>
</blockquote>
<h2 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h2><p>如果一个goroutine的等待时间超过1m后，它会吧当前mutex从正常模式切换到饥饿模式，饥饿模式下，其它尝试获得锁的goroutine不会进行自旋,会直接插入到队<br>列尾部，锁释放后， 会直接给等待队列头部goroutine  </p>
<p>何时从饥饿模式切换为正常模式？<br>当一个goroutine获得锁后 ，以下两种情况会切换回正常模式  </p>
<ol>
<li>它的等待时间小于1ms  </li>
<li>它是最后一个等待者  </li>
</ol>
<blockquote>
<p>饥饿模式下不在自旋，所有goroutine都要排队，用于解决尾端延迟问题</p>
</blockquote>
<h2 id="什么情况下不会自旋"><a href="#什么情况下不会自旋" class="headerlink" title="什么情况下不会自旋"></a>什么情况下不会自旋</h2><ol>
<li>GOMAXPROCS==1   </li>
<li>如果当前runq的等待队列不为空，相比于自旋，切换到本地gorouine更有效率，为保障吞吐也不会自旋  </li>
</ol>
<p>也就是需要满足以下4个条件，才会自旋：  </p>
<ol>
<li>多核，</li>
<li>GOMAXPROCS&gt;1 </li>
<li>当前P的本地队列为空，</li>
<li>有一个P正在执行</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>自旋</li>
<li>排队</li>
<li>饥饿模式开启，禁止自旋</li>
<li>恢复到正常模式</li>
</ol>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>为保证临界区操作的互斥性，一般用锁来实现<br>锁的实现有两种：</p>
<ol>
<li>自旋锁，获得锁如果失败了就不断尝试，直到成功获得锁或者时间片耗完</li>
<li>调度器对象，让出cpu，听从操作系统安排，进入到等待队列中，等待唤醒。调度器对象 也称为线程之间的同步原语，以一种系统调用的形式存在   </li>
</ol>
<p>调度器对象和自旋锁的不同之处主要在于等待队列，同步原语是由内核提供的，之间与系统调度器交互，能够挂起和唤醒线程，这点是自旋锁做不到的，正由于其在内核<br>中实现，所以应用程序中需要以系统调用的方式来实现它，系统调用就会有一定开销，且获取锁失败也会发生线程切换，使得开销加大 </p>
<p>调度器对象和自旋锁各有各的应用场景   </p>
<ol>
<li>如果是多核情况，且持有锁的时间占比较小，往往自旋几次就能拿到锁 </li>
<li>若是单核环境或者持有锁的时间占比较大的情况，一味自旋，就算把时间片耗完，也拿不到锁，空耗cpu得不偿失，</li>
</ol>
<p>在实际业务场景中加锁的时间是不确定的，如果加锁时先经过自旋，但限制最大自旋次数，若在有限次数内，不能加锁成功，再通过调度器对象将线程挂起 也是如今主流的<br>锁实现思路   </p>
<h3 id="runtime-mutex"><a href="#runtime-mutex" class="headerlink" title="runtime.mutex"></a>runtime.mutex</h3><p>go语言中runtime.mutex 就是这个思路，结合自旋锁和调度器对象优化过后的锁，针对线程设计</p>
<h3 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h3><p>协程如果要等待一个锁时，要如何休眠等待和唤醒呢？<br>需要通过 runtime.semaphone来实现， semaphone 是供协程使用的信号量，runtime内部通过一个 大小为251的semaTable,来管理所有的semaphone<br>semaTable 存储的是251棵平衡数的根，平衡树中每个节点都是一个sudog的对象，要使用一个信号量时需要提供一个记录信号量数值的变量，根据变量地址进行计算<br>映射到semaTable中的一棵平衡树上，找到对应的节点就找到了改信号量的等待队列。<br><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_12.png" alt="img.png"><br>如果有协程要等待mutex,就会根据sync.Muxtex.sema 的地址映射到semaTable中的某棵平衡树上，找到对应的sudog类型的节点，也就找到了这个Mutex的等待队列<br>所以sync.Mutex是通过信号量来实现排队的，<br>而channel需要有读等待队列和写等待队列，还要支持缓冲区功能，所以并没有直接使用信号量来排队，而是自己实现一套排队逻辑   </p>
<p>不管是 sync.Mutex还是channel 底层实现都离不开 runtime.mutex,他们对需要保证在面临多线程并发时，不会出现同步问题。<br><img src="/2023/01/11/go/go%E7%A1%AC%E6%A0%B8%E5%B9%B2%E8%B4%A7/img_13.png" alt="img.png"></p>
<h1 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h1><p>T 和 <em>T 是两种类型分别有自己的类型元数据<br>自定义类型的类型元数据可以找到该类型关联的方法列表，T和</em>T各有各的方法集</p>
<h2 id="为什么要限制T和-T不能定义同名方法-？"><a href="#为什么要限制T和-T不能定义同名方法-？" class="headerlink" title="为什么要限制T和*T不能定义同名方法 ？"></a>为什么要限制T和*T不能定义同名方法 ？</h2><p>T类型的方法集里包含的是全部有明确定义的方法<br>*T的方法集里面，除了有明确定义的方法，还会有编译器生成的包装方法， 包装方法是对接受者为T类型的同名方法的包装  </p>
<p>为什么编译器会为接受者为T的方法包装一个*T的同名方法呢？</p>
<blockquote>
<p>通过<em>T类型的变量，直接调用T类型接受的方法，只是一种语法糖，这种调用方式，编译器会在调用端进行指针解引用，并不会用到接受者为</em>T的包装方法  </p>
</blockquote>
<p>编译器生成包装方法只要是为了支持接口 接口的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"unsafe"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">   A()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">   tab  *itab <span class="comment">//类型元数据</span></span><br><span class="line">   data unsafe.Pointer  <span class="comment">//接口装载的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口包含两个指针，一个是和类型元数据相关，一个存储接口装载的数据，虽然有数据指针，但却不能向使用语法糖那样，通过指针解引用来调用值接受者的方法<br>因为方法的接受者是方法调用时隐含的第一个参数，go语言中函数参数是通过栈来传递的，如果参数是指针类型那就很好实现，平台确定了，指针大小就确定了，如果要<br>解引用为值类型，就要有明确的类型信息，编译器才能确定这个参数，要在栈上占用多大的空间，而对于接口，编译阶段并不能确定它会装载那一类数据，所以编译器<br>也不能生成对应的指令来揭引用 ，一句话： 接口不能使用接受者为值类型的方法</p>
<h2 id="如何解决-接口不能使用接受者为值类型的方法这个问题-？"><a href="#如何解决-接口不能使用接受者为值类型的方法这个问题-？" class="headerlink" title="如何解决 接口不能使用接受者为值类型的方法这个问题 ？"></a>如何解决 接口不能使用接受者为值类型的方法这个问题 ？</h2><p>编译器为值接受者的方法生成接受者为指针类型的同名包装方法，正因如此，如果给T和<em>T 定义了同名包装方法，就会和编译器生成的包装方法冲突。  所以go语言<br>不允许为T和</em>T定义同名方法</p>
<h2 id="T的方法集包含T的方法的说法"><a href="#T的方法集包含T的方法的说法" class="headerlink" title="*T的方法集包含T的方法的说法"></a>*T的方法集包含T的方法的说法</h2><p>虽然编译器会为接受者为T的方法生成 接受者为*T的包装方法，但是链接器会把程序中确定不用的方法都裁剪掉，如果去分析可执行文件的话，不止是包装方法就连<br>明确定义的方法，也不一定会存在于可执行文件中</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>结构体 T和*T的方法都可以调用</li>
<li>如果是接口类型的变量，只有*T的方法能够调用T的方法，如果用T，不能赋值给接口，编译不通过，</li>
<li>如果是接口类型的变量，即使是<em>T能够调用T的方法，传入函数的是</em>T对应值的拷贝，不能更改结构体的值</li>
<li>不管调用者是谁，决定是否能改变结构体值的唯一因素只有接受者是否为指针类型，为指针就能改变对象的值，否则不能</li>
</ol>
<h1 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h1><p>在go1.2之前，go的调度器不支持抢占式调度，程序只能依靠Goroutine主动让出资源才能触发调度，这会引发一些问题，比如：  </p>
<ul>
<li>某些Goroutine可以长时间占用线程，造成其它的Goroutine饥饿  </li>
<li>垃圾回收是需要stop the world的如果垃圾回收想要运行，那么它必须通知其它goroutine停下来，这会造成较长的等待时间  </li>
</ul>
<p>为解决这个问题 </p>
<ul>
<li>Go1.2实现了基于协作的抢占式调度</li>
<li>Go1.14实现了基于信号的抢占式调度  </li>
</ul>
<h2 id="基于协作的抢占式调度"><a href="#基于协作的抢占式调度" class="headerlink" title="基于协作的抢占式调度"></a>基于协作的抢占式调度</h2><p>协作式：大家都按事先定义好的规则来，比如：一个goroutine执行完后，退出，让出p，然后下一个goroutine 被调度到p上运行，这样做的的缺点就在于，是否<br>让出p的决定权在goroutine自身，一旦某个g不主动让出或者执行的时间比较长，那后面的goroutine只能等着，没有方法让前者让出p，导致延迟甚至饿死。  </p>
<p>非协作式：由runtime来决定一个goroutine运行多长时间，如果你不主动让出，就踢出去，让后面的goroutine进来运行  </p>
<p>基于协作的抢占式调度流程：</p>
<ol>
<li>编译器会在调用函数前插入runtime.morestack 让运行时有机会在这段代码中检查是否需要执行抢占调度</li>
<li>Go语言运行时会在垃圾回收暂停程序,系统监控发现goroutine运行超过10ms，那么会在这个协程所在的p设置一个抢占标记</li>
<li>当发生函数调用时，可能会执行编译器插入的runtime.morestack，它调用的runtime.newstack会检查抢占标识,如果有抢占标记就会触发抢占，让出p</li>
</ol>
<p>这个方案只能说局部解决了 “饿死”问题，只在函数调用的地方才能插入抢占代码 （埋点），对于没有函数调用而是纯算法循环计算的G,go调度器依然无法抢占</p>
<p>案例1 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span>&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"I got scheduled"</span>)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在1.13之前会卡住，因为就算是goroutine 所在的p被标记了抢占，但是没有调度，没有新的函数执行，p会一直被goroutine 占有  </p>
<p>案例2</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			n++</span><br><span class="line">			fmt.Println(n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(<span class="number">0</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在1.13之前，会输出一段时间的n后停止，因为当gc执行stw的时候，会抢占gorouine,而 main函数的 for{}一直不退出，导致main函数所在的p，一直不被抢占<br>gc 停了所有的p 在等待 main函数占有的p， fmt.Println 涉及io,会陷入系统调用，从而让出p，当p不可获得的时候就卡住了。</p>
<p>为解决协作式抢占调度带来的问题，Go在1.14版本中增加了对非协作式抢占式调度的支持，这种抢占式调度是基于系统信号的，也就是通过向线程发送信号的方式来抢占<br>正在运行的goroutine</p>
<h2 id="基于信号的抢占式调度"><a href="#基于信号的抢占式调度" class="headerlink" title="基于信号的抢占式调度"></a>基于信号的抢占式调度</h2><p>真正的抢占式调度是基于信号完成的，所以也称为“异步抢占”。不管协程有没有意愿主动让出cpu运行权，只要某协程执行的时间过长就会发送信号强行抢夺cpu的运行权  </p>
<ol>
<li>M注册一个SIGURG信号的处理函数，sighandler</li>
<li>sysmon启动后会间隔性的进行监控，最长间隔10ms，最短间隔20us，如果发现某协程独占p超过10ms，会给M发送抢占信号</li>
<li>M收到信号后，内核执行sighandler函数把当前协程状态从 _Gruning正在执行改成 _Grunable可执行，把抢占的协程放到全局队列里，M继续寻找其它的goroutine来执行</li>
<li>被抢占的G再次调度过来执行时，会继续执行原来的执行流程</li>
</ol>
<p>抢占分为_Pruning 和_Psyscall ,_Psyscall抢占通常时由于阻塞性系统调用引起的，比如磁盘io，cgo。<br>_Pruning 抢占通常是由于一些类似死循环的计算逻辑引起的  </p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/01/11/go/go%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/" rel="prev" title="go/go学习书籍">
      <i class="fa fa-chevron-left"></i> go/go学习书籍
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/01/11/go/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/" rel="next" title="go/企业级微服务网关">
      go/企业级微服务网关 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-number">1.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#slice"><span class="nav-number">2.</span> <span class="nav-text">slice</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#slice-扩容规则"><span class="nav-number">2.1.</span> <span class="nav-text">slice 扩容规则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存对齐"><span class="nav-number">3.</span> <span class="nav-text">内存对齐</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要内存对齐？"><span class="nav-number">3.1.</span> <span class="nav-text">为什么要内存对齐？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是内存对齐-？"><span class="nav-number">3.2.</span> <span class="nav-text">什么是内存对齐 ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平台对应的最大对齐边界"><span class="nav-number">3.3.</span> <span class="nav-text">平台对应的最大对齐边界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体占用字节数"><span class="nav-number">3.4.</span> <span class="nav-text">结构体占用字节数?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map"><span class="nav-number">4.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#选桶算法-m为桶的数量-："><span class="nav-number">4.1.</span> <span class="nav-text">选桶算法(m为桶的数量)：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash冲突"><span class="nav-number">4.2.</span> <span class="nav-text">hash冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash扩容"><span class="nav-number">4.3.</span> <span class="nav-text">hash扩容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go语言中Map类型的底层实现就是哈希表"><span class="nav-number">4.4.</span> <span class="nav-text">go语言中Map类型的底层实现就是哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go-Map的扩容规则"><span class="nav-number">4.5.</span> <span class="nav-text">go Map的扩容规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#等量扩容"><span class="nav-number">4.5.1.</span> <span class="nav-text">等量扩容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数调用栈"><span class="nav-number">5.</span> <span class="nav-text">函数调用栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#go语言中返回值赋值早于defer函数"><span class="nav-number">5.1.</span> <span class="nav-text">go语言中返回值赋值早于defer函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个函数中调用了多个函数，且参数和返回值各不相同"><span class="nav-number">5.2.</span> <span class="nav-text">一个函数中调用了多个函数，且参数和返回值各不相同</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#闭包"><span class="nav-number">6.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么需要通过funcval结构体来包装执行函数的地址-然后使用一个二级指针来调用呢？"><span class="nav-number">6.1.</span> <span class="nav-text">为什么需要通过funcval结构体来包装执行函数的地址,然后使用一个二级指针来调用呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包函数是如何找到对应的捕获列表呢？"><span class="nav-number">6.2.</span> <span class="nav-text">闭包函数是如何找到对应的捕获列表呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#捕获列表"><span class="nav-number">6.3.</span> <span class="nav-text">捕获列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#情况1"><span class="nav-number">6.3.1.</span> <span class="nav-text">情况1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#情况2"><span class="nav-number">6.3.2.</span> <span class="nav-text">情况2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#情况3"><span class="nav-number">6.3.3.</span> <span class="nav-text">情况3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#情况4"><span class="nav-number">6.3.4.</span> <span class="nav-text">情况4</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法"><span class="nav-number">7.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#方法表达式与方法变量"><span class="nav-number">7.1.</span> <span class="nav-text">方法表达式与方法变量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#defer"><span class="nav-number">8.</span> <span class="nav-text">defer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#go1-12defer-的问题"><span class="nav-number">8.1.</span> <span class="nav-text">go1.12defer 的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go1-13和go1-14对defer的改进"><span class="nav-number">8.2.</span> <span class="nav-text">go1.13和go1.14对defer的改进</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#panic和recover"><span class="nav-number">9.</span> <span class="nav-text">panic和recover</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#panic-两点重要信息"><span class="nav-number">9.1.</span> <span class="nav-text">panic 两点重要信息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型系统"><span class="nav-number">10.</span> <span class="nav-text">类型系统</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#接口"><span class="nav-number">11.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#空接口-interface"><span class="nav-number">11.1.</span> <span class="nav-text">空接口 interface{}</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非空接口"><span class="nav-number">11.2.</span> <span class="nav-text">非空接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型断言"><span class="nav-number">12.</span> <span class="nav-text">类型断言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#反射-reflect"><span class="nav-number">13.</span> <span class="nav-text">反射 reflect</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GMP"><span class="nav-number">14.</span> <span class="nav-text">GMP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#golang调度器的由来"><span class="nav-number">14.1.</span> <span class="nav-text">golang调度器的由来</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单进程时代的两个问题"><span class="nav-number">14.1.1.</span> <span class="nav-text">单进程时代的两个问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多进程、多线程的问题"><span class="nav-number">14.1.2.</span> <span class="nav-text">多进程、多线程的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#携程"><span class="nav-number">14.1.3.</span> <span class="nav-text">携程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#golang-调度器的优化"><span class="nav-number">14.1.4.</span> <span class="nav-text">golang 调度器的优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GMP模型设计思想"><span class="nav-number">14.2.</span> <span class="nav-text">GMP模型设计思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GMP模型简介"><span class="nav-number">14.2.1.</span> <span class="nav-text">GMP模型简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GMP含义"><span class="nav-number">14.2.1.1.</span> <span class="nav-text">GMP含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全局队列"><span class="nav-number">14.2.1.2.</span> <span class="nav-text">全局队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#P的本地队列"><span class="nav-number">14.2.1.3.</span> <span class="nav-text">P的本地队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#P列表"><span class="nav-number">14.2.1.4.</span> <span class="nav-text">P列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#M列表"><span class="nav-number">14.2.1.5.</span> <span class="nav-text">M列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#P和M的数量"><span class="nav-number">14.2.1.6.</span> <span class="nav-text">P和M的数量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度器的设计策略"><span class="nav-number">14.2.2.</span> <span class="nav-text">调度器的设计策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#复用线程"><span class="nav-number">14.2.2.1.</span> <span class="nav-text">复用线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#利用并行"><span class="nav-number">14.2.2.2.</span> <span class="nav-text">利用并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抢占"><span class="nav-number">14.2.2.3.</span> <span class="nav-text">抢占</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全局G队列"><span class="nav-number">14.2.2.4.</span> <span class="nav-text">全局G队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-fun-经历了什么过程"><span class="nav-number">14.2.3.</span> <span class="nav-text">go fun() 经历了什么过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度器的生命周期"><span class="nav-number">14.2.4.</span> <span class="nav-text">调度器的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#M0"><span class="nav-number">14.2.4.1.</span> <span class="nav-text">M0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G0"><span class="nav-number">14.2.4.2.</span> <span class="nav-text">G0</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可视化的GMP编程"><span class="nav-number">14.2.5.</span> <span class="nav-text">可视化的GMP编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#trance编程"><span class="nav-number">14.2.5.1.</span> <span class="nav-text">trance编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过Debug-trance查看GMP信息"><span class="nav-number">14.2.5.2.</span> <span class="nav-text">通过Debug trance查看GMP信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GO调度器GMP场景过程全分析"><span class="nav-number">14.3.</span> <span class="nav-text">GO调度器GMP场景过程全分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#G1创建G3"><span class="nav-number">14.3.1.</span> <span class="nav-text">G1创建G3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1执行完毕"><span class="nav-number">14.3.2.</span> <span class="nav-text">G1执行完毕</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更多场景见"><span class="nav-number">14.3.3.</span> <span class="nav-text">更多场景见</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GC"><span class="nav-number">15.</span> <span class="nav-text">GC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#标记清扫算法"><span class="nav-number">15.1.</span> <span class="nav-text">标记清扫算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三色标记"><span class="nav-number">15.1.1.</span> <span class="nav-text">三色标记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记清扫算法带来的问题和解决方案"><span class="nav-number">15.1.2.</span> <span class="nav-text">标记清扫算法带来的问题和解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用计数垃圾回收"><span class="nav-number">15.2.</span> <span class="nav-text">引用计数垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STW（stop-the-word）"><span class="nav-number">15.3.</span> <span class="nav-text">STW（stop the word）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收的方式"><span class="nav-number">15.4.</span> <span class="nav-text">垃圾回收的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#增量式垃圾回收"><span class="nav-number">15.4.1.</span> <span class="nav-text">增量式垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写屏障"><span class="nav-number">15.4.2.</span> <span class="nav-text">写屏障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读屏障"><span class="nav-number">15.4.3.</span> <span class="nav-text">读屏障</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多核"><span class="nav-number">15.5.</span> <span class="nav-text">多核</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并行垃圾回收"><span class="nav-number">15.5.1.</span> <span class="nav-text">并行垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发垃圾回收"><span class="nav-number">15.5.2.</span> <span class="nav-text">并发垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主体并发式垃圾回收"><span class="nav-number">15.5.3.</span> <span class="nav-text">主体并发式垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主体并发增量式回收"><span class="nav-number">15.5.4.</span> <span class="nav-text">主体并发增量式回收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC-触发方式"><span class="nav-number">15.6.</span> <span class="nav-text">GC 触发方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mutex"><span class="nav-number">16.</span> <span class="nav-text">Mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#正常模式"><span class="nav-number">16.1.</span> <span class="nav-text">正常模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#饥饿模式"><span class="nav-number">16.2.</span> <span class="nav-text">饥饿模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么情况下不会自旋"><span class="nav-number">16.3.</span> <span class="nav-text">什么情况下不会自旋</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">16.4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量"><span class="nav-number">16.5.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#runtime-mutex"><span class="nav-number">16.5.1.</span> <span class="nav-text">runtime.mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sync-Mutex"><span class="nav-number">16.5.2.</span> <span class="nav-text">sync.Mutex</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法集"><span class="nav-number">17.</span> <span class="nav-text">方法集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要限制T和-T不能定义同名方法-？"><span class="nav-number">17.1.</span> <span class="nav-text">为什么要限制T和*T不能定义同名方法 ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何解决-接口不能使用接受者为值类型的方法这个问题-？"><span class="nav-number">17.2.</span> <span class="nav-text">如何解决 接口不能使用接受者为值类型的方法这个问题 ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#T的方法集包含T的方法的说法"><span class="nav-number">17.3.</span> <span class="nav-text">*T的方法集包含T的方法的说法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">17.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#抢占式调度"><span class="nav-number">18.</span> <span class="nav-text">抢占式调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基于协作的抢占式调度"><span class="nav-number">18.1.</span> <span class="nav-text">基于协作的抢占式调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于信号的抢占式调度"><span class="nav-number">18.2.</span> <span class="nav-text">基于信号的抢占式调度</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chen Yu"
      src="/images/head.jpeg">
  <p class="site-author-name" itemprop="name">Chen Yu</p>
  <div class="site-description" itemprop="description">自律给我自由</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Yu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
